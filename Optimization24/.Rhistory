rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
n
Q
rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
n
c
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
c
n
c
n
Q
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x)))) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x)))) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x)))) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x)))) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x)))) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN )           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN )           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN )           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN )           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN )           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN )           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  + grad_PEL_TZ2(x)*c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  + grad_PEL_TZ2(x)*c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  + grad_PEL_TZ2(x)*c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  + grad_PEL_TZ2(x)*c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  + grad_PEL_TZ2(x)*c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  + grad_PEL_TZ2(x)*c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  + grad_PEL_TZ2(x)*c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     a <- KP_TZ1(x)     b <- KP_TZ2(x)     c <- KP_TZ5(x)     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN)           )) } grad_fc1 = function(x) {     a <- grad_KP_TZ1(x)     b <- grad_KP_TZ2(x)     c <- grad_KP_TZ5(x)     return(-((grad_PEL_TZ1(x) * c_RDN  + grad_PEL_TZ2(x)*c_RDN ))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 2,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu setwd(getwd()) source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu setwd(getwd()) source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu setwd(getwd()) source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu setwd(getwd()) source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu setwd(getwd()) source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu setwd(getwd()) source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints) a <- equalities(x_test))$constraints cat("\nConstraints:", (a %% 25 == 0 ) || a == 1)
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints) a <- equalities(x_test))$constraints cat("\nConstraints:", a[(a %% 25 == 0 ) || a == 1])
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) cat("\nConstraints:", (equalities(x_test))$constraints) a <- equalities(x_test)$constraints cat("\nConstraints:", a[(a %% 25 == 0 ) || a == 1])
rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
cat("\nConstraints:", a[1], a[a %% 25 == 0])
cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints)))
Q
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c(a[1], a[a %% 25 == 0]) cat("\nConstraints:", a[a %% 25 == 0]) cat("\nConstraints abs sum:", sum(abs(a)))
cat("\nConstraints abs sum:", sum(abs(constraints_test)))
cat(length(constraints_test))
a <- equalities(x_test)$constraints constraints_test <- c() for (i in 1:24) {     constraints_test <- c(constraints_test,a[i+24*0])     constraints_test <- c(constraints_test,a[i+24*1])     constraints_test <- c(constraints_test,a[i+24*2]) } cat(constraints_test)
a <- equalities(x_test)$constraints constraints_test <- c() for (i in 1:24) {     constraints_test <- c(constraints_test,a[i+24*0])     constraints_test <- c(constraints_test,a[i+24*1])     constraints_test <- c(constraints_test,a[i+24*2]) } cat(constraints_test)
cat(length(equalities(x_test)$constraints))
constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat(constraints_test)
# zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 15, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat(constraints_test) cat(length(equalities(x_test)$constraints))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 15, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 60,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 45,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 35,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 35,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 25,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 25,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 25,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 25,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 10, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-10, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 40,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nConstraints:", (equalities(optim$solution))$constraints) cat("\nConstraints abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nConstraints:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 40,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 40,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-15)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 40,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 40,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 995000,           # 1000          "maxtime" = 25,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 10,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
F_mST_25_KS4 = function() {     mST <- c()     for (i in 1:24) {         mST_i = 0         if (mST_KS4[i] < 150) {             mST_i = 0         } else if (mST_KS4[i] < 250) {             mST_i = 0.0833 * mST_KS4[i] + 4.8535         } else if (mST_KS4[i] < 350) {             mST_i = 0.0312 * mST_KS4[i] + 20.165         } else {             mST_i = 0.0266 * mST_KS4[i] + 20.336         }         mST <- c(mST, mST_i)     }     return (mST) } G_mST_25_KS4 = function(x) {     grad <- c()     for (i in 1:24) {         grad[[i]]=c(0,0,0,0,0,0,0,0,0,0,0,0,0,0)     }     return (grad) }
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
Q
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
n
c
n
c
n
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
Q
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-5)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = true, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     #eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     #eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę pl1 <- 0 fc1 = function(x) {     return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -            sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x)))) } grad_fc1 = function(x) {     return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -            (grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-10)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-24,          "ftol_rel" = 1.0e-17,          "ftol_abs" = 1.0e-17,          "xtol_abs" = 1.0e-24) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     #eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny x_test <- c() x_test <- c(x_test, optim$solution[1+24*0] - 3, rep(0, times = 23)) #TZ1 x_test <- c(x_test, optim$solution[1+24*1], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*2], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*3]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*4], rep(0,times=23)) #TZ2 x_test <- c(x_test, optim$solution[1+24*5], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*6], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*7]+3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*8]-3, rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*9], rep(0,times=23)) #TZ5 x_test <- c(x_test, optim$solution[1+24*10], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*11], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*12], rep(0,times=23)) x_test <- c(x_test, optim$solution[1+24*13], rep(0,times=23)) cat(x_test) printVariables(x_test, 1) a <- equalities(x_test)$constraints constraints_test <- c()     constraints_test <- c(constraints_test,a[1+24*0])     constraints_test <- c(constraints_test,a[1+24*1])     constraints_test <- c(constraints_test,a[1+24*2])     constraints_test <- c(constraints_test,a[1+24*3])     constraints_test <- c(constraints_test,a[1+24*4])     constraints_test <- c(constraints_test,a[1+24*5])     constraints_test <- c(constraints_test,a[1+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test)))
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x)+KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KP(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KP(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KP(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KP(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KP(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x)) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KP(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(-sum(KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(-(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(-sum(KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(-(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(-sum(KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(-(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(-sum(KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(-(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
source("C:\\Users\\Piotr\\Documents\\Visual Studio 2017\\Projects\\Optimization24\\Optimization24\\Model.R")
rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
n
Q
rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
c
n
c
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(-sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(-(grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(-sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(-(grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(-sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return(-(grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
rtvs::debug_source("~/Visual Studio 2017/Projects/Optimization24/Optimization24/Model.R")
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
Q
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = TRUE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 20,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 30,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 30,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 100,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat(KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 100,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0],  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4]+30,  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+30,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat("\n",KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 100,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0]-15,  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3]+15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4],  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7]+15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]-15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat("\n",KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 100,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0]-15,  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3]+15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4],  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7]+15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]-15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat("\n",KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 30,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0]-15,  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3]+15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4],  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7]+15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]-15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat("\n",KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0]-15,  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3]-15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4],  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7]+15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]-15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat("\n",KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0]-15,  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3]-15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4],  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7]+15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]-15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat("\n",KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 22 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0]-15,  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3]-15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4],  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7]+15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]-15,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat("\n",KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-05)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 15,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-18,          "ftol_rel" = 1.0e-08,          "ftol_abs" = 1.0e-08,          "xtol_abs" = 1.0e-18) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 10 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0]+3,  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3]+3,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4],  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7]-3,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+3,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat("\n",KE(optim$solution) )
# biblioteka optymalizacji library("nloptr") # moduły modelu source("Input.R")         # dane wejściowe source("Variables.R")     # zmienne manipulacyjne source("Constraints.R")   # ograniczenia zmiennych manipulacyjnych source("Dependencies.R")  # zależności (dodatkowe ograniczenia) zmiennych manipulacyjnych source("Turbines.R")      # charakterystyki turbin source("Costs.R")         # koszty source("Auxiliaries.R")   # potrzeby własne #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #   # FC1 - maksymalizuj marżę fc1 = function(x) {     #return(-(sum(PEL_TZ1(x) * c_RDN + PEL_TZ2(x) * c_RDN + PEL_TZ5(x) * c_RDN) -     #sum(KP_TZ1(x) + KP_TZ2(x) + KP_TZ5(x))))     return(sum(KE(x) + KP_TZ1(x)+KP_TZ2(x)+KP_TZ5(x))) } grad_fc1 = function(x) {     #return(-((grad_PEL_TZ1(x) * c_RDN + grad_PEL_TZ2(x) * c_RDN + grad_PEL_TZ5(x) * c_RDN) -     #(grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))))     return((grad_KE(x) + grad_KP_TZ1(x) + grad_KP_TZ2(x) + grad_KP_TZ5(x))) } # optymalizacja local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-08)   #"xtol_rel" = 0.000001,   #"ftol_rel" = 0.000001,   #"ftol_abs" = 0.000001,   #"xtol_abs" = 0.000001)  opts <- list("algorithm" = "NLOPT_LD_SLSQP",          "check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          "maxeval" = 1000,           # 1000          "maxtime" = 60,              # [s]          "local_opts" = local_opts,          "xtol_rel" = 1.0e-14,          "ftol_rel" = 1.0e-07,          "ftol_abs" = 1.0e-07,          "xtol_abs" = 1.0e-14) #opts <- list("algorithm" = "NLOPT_LD_AUGLAG", #NLOPT_GN_ISRES          #"xtol_rel" = 3.0e-1,        # 1.0e-5          #"check_derivatives" = FALSE, # pokaż raport ze sprawdzania pochodnych          #"maxeval" = 5000,           # 1000          #"maxtime" = 17,              # [s]          #"local_opts" = local_opts,          #"ftol_rel" = 0.0) optim <- nloptr(x0 = constraintsDefault,     eval_f = fc1,     eval_grad_f = grad_fc1,     lb = constraintsLB,     ub = constraintsUB,     eval_g_eq = equalities,     eval_g_ineq = inequalities,     opts = opts) optim printVariables(optim$solution,24) cat("\nEqualities:", (equalities(optim$solution))$constraints) cat("\nEqualities abs sum:", sum(abs((equalities(optim$solution))$constraints))) cat("\nInequalities:", (inequalities(optim$solution))$constraints) # zmiana dla jednej godziny cat("/n#   TEST   #") h_test <- 10 x_test <- c() x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*0]+3,  rep(0,times=24-h_test)) #TZ1 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*1],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*2],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*3]+3,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*4],  rep(0,times=24-h_test)) #TZ2 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*5],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*6],  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*7]-3,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*8]+3,  rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*9],  rep(0,times=24-h_test)) #TZ5 x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*10], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*11], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*12], rep(0,times=24-h_test)) x_test <- c(x_test, rep(0,h_test-1), optim$solution[h_test+24*13], rep(0,times=24-h_test)) printVariables(x_test, h_test) a <- equalities(x_test)$constraints constraints_test <- c() constraints_test <- c(constraints_test,a[h_test+24*0]) constraints_test <- c(constraints_test,a[h_test+24*1]) constraints_test <- c(constraints_test,a[h_test+24*2]) constraints_test <- c(constraints_test,a[h_test+24*3]) constraints_test <- c(constraints_test,a[h_test+24*4]) constraints_test <- c(constraints_test,a[h_test+24*5]) constraints_test <- c(constraints_test,a[h_test+24*6]) cat("\nConstraints:", constraints_test) cat("\nConstraints abs sum:", sum(abs(constraints_test))) cat("\n",KE(optim$solution) )
